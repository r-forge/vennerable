<<eval=FALSE,echo=FALSE>>=
makeme <- function() {
	setwd("C:/JonathanSwinton/Vennerable/pkg/Vennerable/inst/doc")
	library(weaver);
	Sweave(driver=weaver,"Euler3Sets.Rnw",stylepath=FALSE,use.cache=FALSE)
}
makeme()
@
\documentclass[a4paper]{article}
\usepackage{natbib}
\title{
Distinct patterns
for zeroes in Euler diagrams
on three sets
}
\author{Jonathan Swinton}

\usepackage{Sweave}
\SweaveOpts{debug=TRUE,eps=FALSE,echo=TRUE}
%\VignetteIndexEntry{Internal use only}


\usepackage{mathptmx}
\usepackage{rotating} 
\usepackage[nodayofweek]{datetime}\longdate
\usepackage{hyperref}
\usepackage{float}
\usepackage{fancyhdr}
\begin{document}

\maketitle\thispagestyle{fancy}

This vignette does not need to be read to understand the \texttt{Vennerable} package.


The Euler diagram on three sets has seven regions
which are not dark matter. If the weight associated 
to the region is zero, we do not want to display the
region. The number of possible patterns of zeros
is $2^7=\Sexpr{2^7}$ but many of these patterns
are symmetric under a relabelling of the original sets.

How many distinct zero-patterns are there, allowing set relabelling?

<<>>=
library(xtable)
vs <- expand.grid(A=c(0,1),B=c(0,1),C=c(0,1))
vs$VS <- apply(data.matrix(vs[,1:3]),1,paste,collapse="")
vs <- subset(vs,VS!="000")


Euler.from.vs <- function(vs) {
	w <- lapply(vs$VS,function(x){c(0,1)})
	names(w) <- vs$VS
	Eulers <- do.call(expand.grid,w)
	Eulers$VS <- apply(data.matrix(Eulers),1,paste,collapse="")
	Eulers
}


library(gtools)
worder <-   permutations(3,3)
worder <- lapply(1:nrow(worder),function(x){worder[x,]})
P2 <- lapply(worder,function(x) {
	wname <- paste("Order",paste(x,collapse=""))
#	cat(wname,"\n")
	vs.order <- vs[,x]
	E2 <- Euler.from.vs(vs)
	E2 <- E2[do.call(order,E2[,1:7]),]
	vs.order$VS <- apply(data.matrix(vs.order),1,paste,collapse="")
	vs.perm <- match(vs.order$VS,vs$VS)
	E2.perm <- E2[,vs.perm]
	E2.perm$VS  <- apply(data.matrix(E2.perm),1,paste,collapse="")
	E2.perm$VS
	}
)


# now E2 has the indicator strings generated by all possible orderings
# with the corresponding row names
E3 <- do.call(rbind,P2)
F3 <- unique(apply(E3,2,function(x)(unique(sort(x)))))
iclasses <- (sapply(F3,paste,collapse=";"))
rclasses <- sapply(F3,function(x)x[1])

irclasses <- data.frame(VS=rclasses,iclasses=iclasses,stringsAsFactors=FALSE)
E1 <- Euler.from.vs(vs)
Eclass <- merge(E1,irclasses)
rownames(Eclass) <- 1:nrow(Eclass)
Eclass <- Eclass[order(Eclass$VS),]

@

However some of these (eg 0000010) correspond to
patterns in which every region at least one set is empty.
<<>>=
vsnames <- names(E1)[1:7]
vsmat <- do.call(rbind,strsplit(vsnames,split=""))
isa <- vsnames[vsmat[,1]=="1"]
isb <- vsnames[vsmat[,2]=="1"]
isc <- vsnames[vsmat[,3]=="1"]

havea <- apply(Eclass[,isa],1,sum)>0
haveb <- apply(Eclass[,isb],1,sum)>0
havec <- apply(Eclass[,isc],1,sum)>0

Ehave <- Eclass[havea & haveb & havec,]
rownames(Ehave) <- 1:nrow(Ehave)
@
There are \Sexpr{nrow(Ehave)} patterns with all sets
represented
<<results=tex>>=
print(xtable(Ehave,digits=0),size="small"
)
@

<<>>=
E3List <- lapply(Ehave$VS,function(VS){
	Weights <- t(Ehave[Ehave$VS==VS,2:8])[,1]
	Weights["000"] <- 0
	Weights <- Weights[order(names(Weights))]
	Weights
})
names(E3List) <- Ehave$VS


V <- Venn(Weight=E3List[["0000001"]],SetNames=LETTERS[1:3])
C3 <- try(compute.Venn(V))
}
@

\cite{edwards:2004}
\bibliographystyle{plain}
\bibliography{./Venn}
\end{document}

