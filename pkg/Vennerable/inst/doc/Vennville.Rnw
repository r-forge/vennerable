%**************************************************************************
%
% # $Id$
%\VignetteIndexEntry{Obsolete}

<<defmakeme,echo=FALSE,eval=FALSE>>=
makeme <- function() {
	if ("package:Vennerable" %in% search()) detach("package:Vennerable")
	library(weaver)
	setwd("C:/JonathanSwinton/Vennerable/pkg/Vennerable/inst/doc")
	Sweave(driver="weaver","Vennville.Rnw",stylepath=FALSE,use.cache=FALSE)
}
makeme()
@


\documentclass[a4paper]{article}


\title{
Venn diagrams 
\\
Technical details and 
regression checks
}
\author{Jonathan Swinton}

\usepackage{Sweave}
\SweaveOpts{prefix.string=Vennville,cache=TRUE,debug=TRUE,eps=FALSE,echo=FALSE,pdf.version=1.4}
\usepackage{natbib}
\usepackage{mathptmx}
\usepackage{rotating} 
\usepackage{float} 
\usepackage[nodayofweek]{datetime}\longdate
\usepackage{hyperref}
\begin{document}


\maketitle

\begin{itemize}
\item Try CR for weight=0
\item implement not showing dark matter eg Fig 1
\item Different choices of first and second sets for AWFE
\item Add in the equatorial sets for AWFE
\item AWFE-book like figures
\item  naming of weights for triangles
\item  likesquares argument for triangles
\item  central dark matter
\item Comment on triangles
\item Comment on AWFE
return geometry
\item text boxes
\item use grob objects/printing properly
 \item proper data handling:
\item choose order; 
\item cope with missing data including missing zero intersection; 
\item Define weights via names
\item graphical parameters
\item discuss Chow-Ruskey zero=nonsimple 

\end{itemize}

<<doremove,echo=FALSE>>=
remove(list=setdiff(ls(),"makeme"));
@

<<loadmore,echo=FALSE>>=
options(width=45)
@
\section{Venn objects}

<<echo=TRUE>>=
library(Vennerable)
Vcombo <- Venn(SetNames=c("Female","Visible Minority","CS Major"),
	Weight= c(0,4148,409,604,543,67,183,146)
)
@

For a running example, we use sets named after months,
whose elements are the letters of their names.
<<mvn1,echo=TRUE>>=
setList <- strsplit(month.name,split="")
names(setList) <- month.name
VN3 <- VennFromSets( setList[1:3])
V2 <- VN3[,c("January","February"),]
@

<<checkV,echo=FALSE>>=
stopifnot(NumberOfSets(V2)==2)
@

<<V4,echo=TRUE>>=
V4 <-  VennFromSets( setList[1:4])
V4f <- V4
V4f@IndicatorWeight[,".Weight"] <- 1
@

<<mvn,echo=TRUE>>=
setList <- strsplit(month.name,split="")
names(setList) <- month.name
VN3 <- VennFromSets( setList[1:3])
V2 <- VN3[,c("January","February"),]
@
<<echo=TRUE>>=
V3.big <- Venn(SetNames=month.name[1:3],Weight=2^(1:8))
V2.big <- V3.big[,c(1:2)]
@

<<otherV,echo=TRUE>>=


Vempty <- VennFromSets( setList[c(4,5,7)])
Vempty2 <- VennFromSets( setList[c(4,5,11)])
Vempty3 <- VennFromSets( setList[c(4,5,6)])

@


\begin{figure}[H]
\begin{center}
<<tv,fig=TRUE,echo=FALSE>>=
grid.newpage()
pushViewport(dataViewport( xData= c(-1,1),yData=c(-1,1),name="plotRegion"))
x <- c( -.7, .1, .4)
y <- c(-.4,-.3,.6)
grid.polygon(x,y,default.units="native")
grid.text(x=x+c(-0.05,0,0.05),y=y,c("A","B","C"),default.units="native",just="left")
sab <- c(0.3 ,0.4, 0.5)
xmp <- x * sab + (1-sab) * x[c(2,3,1)]
ymp <- y * sab + (1-sab) * y[c(2,3,1)]
grid.points(x=xmp,y=ymp,pch=20,default.units="native")
grid.polygon(x=xmp,y=ymp,gp=gpar(lty="dotted"),default.units="native")
grid.text (x=(x+xmp)/2+c(0,0.05,0),y=(y+ymp)/2+c(-.05,0,0.05),label=c(expression(s[c] *c),expression(s[a] *a),expression(s[b] *b)),default.units="native")
@
\end{center}\end{figure}
Given a triangle $ABC$ of area $\Delta$ and some nonnegative weights $w_a+w_b+w_c<1$
 we want to set $s_c$, $s_a$ and $s_b$ so that the areas of each of the apical triangles
are $\Delta$-proportional to $w_a$, $w_b$ and $w_c$.
This means
\begin{eqnarray}
 s_c (1-s_b) bc \sin A &=& 2 w_a \Delta
\\
s_a (1-s_c) ca  \sin B &=& 2 w_b \Delta
\\
s_b (1-s_a) ab \sin C &=& 2 w_c \Delta
\end{eqnarray}
So \begin{eqnarray}
 s_c (1-s_b) &=& w_a
\\
s_a (1-s_c) &=& w_b
\\
s_b (1-s_a) &=& w_c
\end{eqnarray}
\begin{eqnarray}
 s_b  &=&  1- w_a/s_c
\\
s_a  &=&  w_b/(1-s_c)
\\
(s_c-w_a) ( 1-s_c-w_b) &=&  s_c(1-s_c)w_c
\end{eqnarray}
\begin{eqnarray}
 s_c^2 (1-w_c) +s_c (w_b+w_c-w_a-1) +w_a(1-w_b) &=&0
\end{eqnarray}

Iff
\begin{eqnarray}
4 w_a w_b w_c  < (1 -  (w_a+w_b+w_c))^2
\end{eqnarray}
this has two real solutions between $w_a$ and $1-w_b$.

<<>>=
.inscribetriangle.feasible(rep(0.25,3))
@

\subsection{Three triangles}
<<echo=FALSE,results=hide>>=
V3a=Venn(n=3)
T3a <- compute.T3(V3a)
VisibleRange(T3a)
IntersectionMidpoints(T3a)
Areas(T3a)

T3.big <- compute.T3(V3.big)
T3a <- (compute.T3(V3a))
TN <- compute.T3(VN3)
TCombo <- try(compute.T3(Vcombo))

@
	




\section{Chow-Ruskey}
See \cite{chowruskey:2005,chowruskey:2003}.
<<defplo>>=
plot.grideqsc <- function (gridvals) {
	for (x in gridvals) {
		grid.segments(x0=min(gridvals),x1=max(gridvals),y0=x,y1=x,gp=gpar(col="grey"),default.units="native")
		grid.segments(x0=x,x1=x,y0=min(gridvals),y1=max(gridvals),gp=gpar(col="grey"),default.units="native")
	}
}

plot.gridrays  <- function(nSets,radius=3) {	
	k <- if (nSets==3) {6} else {12}
	angleray <- 2*pi / (2*k)
	# the area between two rays at r1 r2 is (1/2) r1 * r2 * sin angleray
	angles <- angleray * (seq_len(2*k)-1)
	for (angle in angles) {
		x <- radius*c(0,cos(angle));y <- radius* c(0,sin(angle))
		grid.lines( x=x,y=y,default.unit="native",gp=gpar(col="grey"))
	}
}

sho4 <- function(CR4) {
	grid.newpage()
	PlotVennGeometry(CR4 ,show=list(FaceText="signature"))
	downViewport("Vennvp")
	plot.grideqsc(-4:4)
	plot.gridrays(NumberOfSets(CR4),radius=5)
}
@





\subsection{Chow-Ruskey diagrams for 3  sets}
The general Chow-Ruskey algorithm can be implemented
in principle for an arbitrary number of sets provided
the weight of the common intersection is nonzero.


\begin{figure}[H]\begin{center}
<<plotCR3,echo=FALSE,fig=TRUE>>=
CR3a <- compute.CR(V3a)
grid.newpage()
PlotVennGeometry(CR3a ,show=list(FaceText="signature"))
downViewport("Vennvp")
#PlotNodes(T3a )
#checkAreas(CR3a )
@
\caption{Chow-Ruskey weighted 3-set diagram}
\end{center}
\end{figure}


\begin{figure}[H]\begin{center}
<<pCR3,fig=TRUE>>=
CR3 <- compute.CR(Venn(n=3))
#checkAreas(CR3)

sho4(CR3 )
@
\end{center}\end{figure}

\begin{figure}[H]\begin{center}
<<pCR3f,fig=TRUE>>=
CR3f <- compute.CR(V3a)
sho4(CR3f )
#checkAreas(CR3f )
@
\caption{Chow-Ruskey CR3f}
\end{center}
\end{figure}

\subsection{Chow-Ruskey diagrams for 4 sets}

\begin{figure}[H]\begin{center}
<<defplotcr4>>=
V4a <- Venn(SetNames=month.name[1:4],Weight=1:16)
CR4a <-  compute.CR(V4a)
grid.newpage()
try(PlotVennGeometry(CR4a ,show=list(FaceText="signature")))
@
<<plotCR4,echo=FALSE,fig=TRUE>>=
# TODO FAILS
@
\caption{Chow-Ruskey weighted 4-set diagram}
\end{center}
\end{figure}



\begin{figure}[H]\begin{center}
<<plotCR4www,echo=FALSE,fig=TRUE>>=
V4W <- Weights(V4a)
V4W[!names(V4W) %in% c("1011","1111","0111")] <- 0
V4W["0111"] <- 10
V4W["1011"] <- 5
V4w <- V4a
Weights(V4w) <- V4W
CR4w <-  compute.CR(V4w)
#checkAreas(CR4w )

#grid.newpage()
#
sho4(CR4w)
angleray <- 2*pi / (2*12)
inr <- 2.26; outr=4.4
grid.text(x=inr *cos(angleray),y=inr *sin(angleray),label="r1",default.units="native")
grid.text(x=1.5 *cos(angleray/2),y=1.5*sin(angleray/2),label="phi",default.units="native")
grid.text(x=inr *cos(0),y=inr *sin(0),label="r2",default.units="native")
grid.text(x=outr *cos(0),y=outr *sin(0),label="s2",default.units="native")
grid.text(x=3*cos(0),y=3*sin(0),label="delta",default.units="native")
grid.text(x=inr *cos(-angleray),y=inr *sin(-angleray),label="r3",default.units="native")
grid.text(x=inr *cos(-7*angleray),y=inr *sin(-7*angleray),label="r[n]",default.units="native")
grid.text(x=outr *cos(-angleray),y=outr *sin(-angleray),label="s3",default.units="native")
grid.text(x=3*cos(-angleray),y=3*sin(-angleray),label="delta",default.units="native")

#PlotVennGeometry(CR4w ,show=list(indicator.string=TRUE,intersection.weight=FALSE))
#downViewport("Vennvp")
#PlotNodes(CR4a )
@
\caption{Chow-Ruskey weighted 4-set diagram}
\end{center}
\end{figure}

\newcommand{\jhalf}{\frac{1}{2}}
The area of the sector $0r_1r_2$ is $\jhalf r_1 r_2 \sin\phi$.
 The area of $0r_1s_2$ is
$\jhalf (r_1 (r_2+\delta) \sin\phi)$ and so the area
 of $r_1 r_2 s_2$ is $\jhalf(r_1\delta\sin\phi)$.

The area of $r_2 r_2 s_2 s_3$ is
 $\jhalf[(r_3+\delta)(r_2+\delta)-r_3 r_2) \sin\phi
=\jhalf[(r_3+r_2)\delta+\delta^2] \sin\phi$.

The total area of the outer shape is
\begin{eqnarray}
A &=& \jhalf(\sin\phi) \left [  (r_1 + r_n)\delta+\sum_{k=2}^{n-2}[ (r_{k+1}+r_k)\delta + \delta^2 ] \right]
\\
&=& \jhalf(\sin\phi) \left [  (r_1 + r_n)\delta+ (n-2)\delta^2 + \delta \sum_{k=2}^{n-2}[ (r_{k+1}+r_k) ] \right]
\\
&=& \jhalf(\sin\phi) \left[ (r_1+r_2+2r_3+ \ldots + 2 r_{n-2} + r_{n-1}+r_n) \delta + (n-3)\delta^2 \right]
\end{eqnarray}
so
\begin{eqnarray}
0 &=& c_a \delta^2+ c_b \delta + c_c 
\\
c_a &=& n-3
\\
c _b &=& r_1+r_2+2r_3+ \ldots + 2 r_{n-2} + r_{n-1}+r_n
\\
c_c &=& -A/\jhalf \sin\phi
\end{eqnarray}

This is implemented in the compute.delta function.

If all the $r$s are the same then $c_b=[2(n-3)+4]r=(2n-2)r$.



These constraints are that
\begin{eqnarray}
4 w_a w_b w_c  < (1 -  (w_a+w_b+w_c))^2
\end{eqnarray}
must hold for both of the sets of numbers
\begin{eqnarray}
w_a &=& w_{100}
\\
w_b &=& w_{010}
\\
w_c &=& w_{001}
\end{eqnarray}
and
\begin{eqnarray}
w_a &=& w_{101}/W
\\
w_b &=& w_{011}/W
\\
w_c &=& w_{011}/W
\end{eqnarray}
where $w_s$ is the normalised weight of the set with indicator string $s$ and
$W=w_{101}+w_{011}+w_{011}+w_{111}=1-(w_{100}+w_{010}+w_{001})$.

\section{This document}

\begin{tabular}{|l|l|}
\hline
Author & Jonathan Swinton
\\
CVS id of this document & ${}$Id${}$.
\\
Generated on & \today
\\
R version & 
<<echo=FALSE,results=tex>>=
cat(R.version.string)
@
\\
\hline
\end{tabular}

\bibliographystyle{plain}
%\bibliography{Venn}

\end{document}
